<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! trunk/opendj3/legal-notices/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2011-2013 ForgeRock AS
  !    
-->
<chapter xml:id='chap-schema'
 xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en'
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:schemaLocation='http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd'
 xmlns:xlink='http://www.w3.org/1999/xlink'
 xmlns:xinclude='http://www.w3.org/2001/XInclude'>
 <title>Managing Schema</title>
 <indexterm><primary>Schema</primary></indexterm>
 
 <para>Schema definitions describe the data, and especially the object classes
 and attribute types that can be stored in the directory. By default OpenDJ
 conforms strictly to LDAPv3 standards pertaining to schema definitions and
 attribute syntax checking, ensuring that data stored is valid and properly
 formed. Unless your data use only standard schema present in OpenDJ when
 you install, then you must add additional schema definitions to account
 the data your applications stored.</para>
 
 <para>Out of the box, OpenDJ comes with many standard schema definitions.
 In addition you can update and extend schema definitions while OpenDJ
 is online. As a result you can add new applications requiring additional
 data without stopping your directory service.</para>
 
 <para>This chapter demonstrates how to change and to extend OpenDJ schema.
 This chapter also identifies the standard schema definitions available when
 you install OpenDJ.</para>
 
 <section xml:id="about-schema">
  <title>About Directory Schema</title>
  
  <para>Directory schema, described in <link
  xlink:href='http://tools.ietf.org/html/rfc4512'>RFC 4512</link>, define
  the kinds of information you find in the directory, and can define how
  the information are related. This chapter focuses primarily on two types
  of directory schema definitions.</para>
  
  <itemizedlist>
   <listitem>
    <para><firstterm>Attribute type</firstterm> definitions describe attributes
    of directory entries, such as <literal>givenName</literal> or
    <literal>mail</literal>.</para>
    <para>Here is an example of an attribute type definition.</para>
    <programlisting language="ldif"># Attribute type definition
attributeTypes: ( 0.9.2342.19200300.100.1.3 NAME ( 'mail' 'rfc822Mailbox' )
  EQUALITY caseIgnoreIA5Match SUBSTR caseIgnoreIA5SubstringsMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26{256} X-ORIGIN 'RFC 4524' )</programlisting>
    <para>Attribute type definitions start with an object identifier (OID),
    and generally a short name or names that are easier to remember than the
    OID. The attribute type definition can specify how attribute values
    should be collated for sorting, and what syntax they use. The X-ORIGIN
    is an extension to identify where the definition originated. When you
    define your one schema, you likely want to provide an X-ORIGIN to help
    you to track versions of definitions, and where the definitions came
    from.</para>
   </listitem>
   <listitem>
    <para><firstterm>Object class</firstterm> definitions identify the
    attribute types that an entry must have, and may have. Examples of
    object classes include <literal>person</literal> and
    <literal>organizationalUnit</literal>.</para>
    <para>Here is an example of an object class definition.</para>
    <programlisting language="ldif"># Object class definition
objectClasses: ( 2.5.6.6 NAME 'person' SUP top STRUCTURAL MUST ( sn $ cn )
  MAY ( userPassword $ telephoneNumber $ seeAlso $ description )
  X-ORIGIN 'RFC 4519' )</programlisting>
    <para>Entries all have an attribute identifying their object classes,
    called <literal>objectClass</literal>.</para>
    <para>Object class definitions start with an object identifier (OID), and
    generally a short name that is easier to remember than the OID. The
    definition here says that the person object class inherits from the top
    object class, which is the top-level parent of all object classes. When
    you view the objectclass attribute values on an entry, you see the list
    of object classes that the entry takes. An entry can have one STRUCTURAL
    object class inheritance branch, such as <literal>top</literal> -
    <literal>person</literal> - <literal>organizationalPerson</literal> -
    <literal>inetOrgPerson</literal>. Yet entries can have multiple
    AUXILIARY object classes. The object class then defines the attribute
    types that must be included, and the attribute types that may be included
    on entries having the object class.</para>
   </listitem>

   <listitem>
    <para>An <firstterm>attribute syntax</firstterm> constrains what directory
    clients can store as attribute values.</para>

    <para>An attribute syntax is identified in an attribute type definition by
    its OID. String-based syntax OIDs are optionally followed by a number, set
    between braces, that represents a minimum upper bound on the number of
    characters in the attribute value. For example, in the attribute type
    definition shown above, the syntax is
    <literal>1.3.6.1.4.1.1466.115.121.1.26{256}</literal>. The syntax is an
    IA5 string (composed of characters from the international version of the
    ASCII character set) that can contain at least 256 characters.</para>

    <para>You can find a table matching attribute syntax OIDs with their
    human-readable names in RFC 4517, <link xlink:show="new"
    xlink:href="http://tools.ietf.org/html/rfc4517#appendix-A">Appendix A.
    Summary of Syntax Object Identifiers</link>. The RFC describes
    attribute syntaxes in detail. Alternatively, you can see the attribute
    syntaxes that OpenDJ supports by opening the OpenDJ Control Panel and
    browsing to Schema &gt; Manage Schema &gt; Attribute Syntaxes. You can
    also list them by using the <command>dsconfig</command> command.</para>

    <para>Although attribute syntaxes are often specified in attribute type
    definitions, directory servers do not always check that attribute values
    comply with attribute syntaxes. OpenDJ directory server does tend to
    enforce compliance by default, in particular for certificates, country
    strings, directory strings, JPEG photos, and telephone numbers. The aim
    is to avoid accumulating garbage in your directory data.</para>

    <para>If you are trying unsuccessfully to import non-compliant data from a
    more lenient directory server, you can either clean the data before
    importing it, or if cleaning the data is not an option, read <xref
    linkend="schema-legacy-support" />.</para>

    <para>When creating your own attribute type definitions, use existing
    attribute syntaxes where possible. If you must create your own attribute
    syntax, then consider the extensions in
    <xref linkend="attr-syntax-schema-definition-extensions" />.</para>
   </listitem>

   <listitem>
    <para>Matching rules determine how the directory server compares attribute
    values to assertion values for LDAP search and LDAP compare
    operations.</para>

    <para>For example, suppose you search with the filter
    <literal>(uid=bjensen)</literal>. The assertion value in this case is
    <literal>bjensen</literal>.</para>

    <para>OpenDJ has the following schema definition for the user ID
    attribute.</para>

    <programlisting language="ldif"
    >attributeTypes: ( 0.9.2342.19200300.100.1.1 NAME ( 'uid' 'userid' )
 EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch
 SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256} X-ORIGIN 'RFC 4519' )</programlisting>

    <para>When finding an equality match for your search, OpenDJ uses the
    <literal>caseIgnoreMatch</literal> matching rule to check for user ID
    attribute values that equal <literal>bjensen</literal> without regard
    to case.</para>

    <para>You can see the matching rules that OpenDJ supports by opening the
    OpenDJ Control Panel and browsing to Schema &gt; Manage Schema &gt;
    Matching Rules. Notice that many matching rules support string collation
    in languages other than English. You can also list matching rules by
    using the <command>dsconfig</command> command.</para>

    <para>As you can read in examples like, <link
    xlink:href="admin-guide#extensible-match-search"
    xlink:role="http://docbook.org/xlink/role/olink"><citetitle>Search: List
    Active Accounts</citetitle></link>, OpenDJ matching rules enable
    directory clients to do more interesting searches than simply comparing
    strings. That example shows how to search for users who have
    authenticated in the last three months.</para>
   </listitem>
  </itemizedlist>
  
  <para>OpenDJ exposes schema over protocol through the
  <literal>cn=schema</literal> entry. OpenDJ stores the schema definitions
  corresponding to the entry in LDIF under the
  <filename>config/schema/</filename> directory. Many standard definitions
  and definitions pertaining to the server configuration are included at
  installation time.</para>
 </section>

 <section xml:id="update-schema">
  <title>Updating Directory Schema</title>
  <indexterm>
   <primary>Replication</primary>
   <secondary>Schema definitions</secondary>
  </indexterm>
  
  <para>OpenDJ directory server is designed to permit updating the list of
  directory schema definitions while the server is running. As a result you can
  add support for new applications that require new attributes or new kinds
  of entries without interrupting the directory service. OpenDJ also replicates
  schema definitions, so the schema you add on one replica are propagated to
  other replicas without you having to intervene manually.</para>
  
  <para>As it is easy to introduce typos into schema definitions, the
  best way to start defining your own schema is with the OpenDJ Control
  Panel. Open the Control Panel &gt; Schema &gt; Manage Schema window to
  get started creating your custom object classes and attribute types.</para>
  
  <mediaobject xml:id="figure-manage-schema">
   <imageobject>
    <imagedata fileref="images/Manage-Schema.png" format="PNG" />
   </imageobject>
  </mediaobject>
  
  <para>As object classes reference attribute types, you first create
  custom attribute types, and then create the object class that references
  the attribute types.</para>
  
  <para>Create a custom attribute type through the New Attribute window.</para>
  
  <mediaobject xml:id="figure-custom-attrtype">
   <imageobject>
    <imagedata fileref="images/custom-attrtype.png" format="PNG" />
   </imageobject>
  </mediaobject>
  
  <para>Using the New Object Class window, create an auxiliary object class
  that allows your new custom attribute type. You set the type to Auxiliary
  under Extra Options.</para>

  <mediaobject xml:id="figure-custom-objclass">
   <imageobject>
    <imagedata fileref="images/custom-objclass.png" format="PNG" />
   </imageobject>
  </mediaobject>
  
  <para>When you finish, the schema changes show up by default in the file
  <filename>config/schema/99-user.ldif</filename>. Notice that the file name
  starts with a number, 99. This number is larger than the numbers prefixing
  other schema file names. In fact, OpenDJ reads the schema files in sorted
  order, reading schema definitions as they occur. If OpenDJ reads a schema
  definition for an object class before it has read the definitions of the
  attribute types mentioned in the object class definition, then it displays
  an error. Therefore, when naming your schema file, make sure the name appears
  in the sorted list of file names <emphasis>after</emphasis> all the schema
  files containing definitions that your schema definitions depends on. The
  default file name for your schema, <filename>99-user.ldif</filename>, ensures
  that your definitions load only after all of the schema files installed by
  default.</para>

  <para>You can create this file in the lab using the Control Panel, and then
  apply the definitions in production by adapting the content for use with the
  <command>ldapmodify</command> command, for example.</para>
  
  <screen>$ cat config/schema/99-user.ldif 
dn: cn=schema
objectClass: top
objectClass: ldapSubentry
objectClass: subschema
cn: schema
attributeTypes: ( temporary-fake-attr-id NAME 'myCustomAttribute' EQUALITY case
 IgnoreMatch ORDERING caseIgnoreOrderingMatch SUBSTR caseIgnoreSubstrings
 Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications )
objectClasses: ( temporary-fake-oc-id NAME 'myCustomObjClass
 ' SUP top AUXILIARY MAY myCustomAttribute )
modifiersName: cn=Directory Manager,cn=Root DNs,cn=config
modifyTimestamp: 20110620095948Z
</screen>

  <para>To test your schema definition, add the object class and attribute
  to an entry.</para>
  
  <screen>$ cat custom-attr.ldif 
dn: uid=bjensen,ou=People,dc=example,dc=com
changetype: modify
add: objectClass
objectClass: myCustomObjClass
-
add: myCustomAttribute
myCustomAttribute: Testing 1, 2, 3...

$ ldapmodify
 --port 1389
 --bindDN "cn=Directory Manager"
 --bindPassword password
 --filename custom-attr.ldif
Processing MODIFY request for uid=bjensen,ou=People,dc=example,dc=com
MODIFY operation successful for DN uid=bjensen,ou=People,dc=example,dc=com
$ ldapsearch
 --port 1389
 --baseDN dc=example,dc=com
 uid=bjensen
 myCustomAttribute
dn: uid=bjensen,ou=People,dc=example,dc=com
myCustomAttribute: Testing 1, 2, 3...
</screen>

  <para>In addition to supporting the standard schema definitions that are
  described in <link xlink:href="http://tools.ietf.org/html/rfc4512#section-4.1"
  >RFC 4512, section 4.1</link>, OpenDJ also supports the following extensions
  that you can use when adding your own definitions.</para>

  <variablelist xml:id="general-schema-definition-extensions">
   <title>Extensions for All Schema Definitions</title>

   <indexterm>
    <primary>Schema</primary>
    <secondary>Schema definition extensions</secondary>
   </indexterm>

   <varlistentry>
    <term><literal>X-ORIGIN</literal></term>
    <listitem>
     <para>Used to specify the origin of a schema element. Examples include
     <literal>X-ORIGIN 'RFC 4519'</literal>, <literal>X-ORIGIN
     'draft-ietf-ldup-subentry'</literal>, and <literal>X-ORIGIN
     'OpenDJ Directory Server'</literal>.</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>X-SCHEMA-FILE</literal></term>
    <listitem>
     <para>Used to specify the relative path to the schema file containing the
     schema element such as <literal>X-SCHEMA-FILE '00-core.ldif'</literal>.
     Schema definitions are located by default in
     <filename>/path/to/opendj/config/schema/*.ldif</filename> files.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <variablelist xml:id="attr-syntax-schema-definition-extensions">
   <title>Extensions for Attribute Syntax Descriptions</title>

   <indexterm>
    <primary>Schema</primary>
    <secondary>Schema definition extensions</secondary>
   </indexterm>

   <varlistentry>
    <term><literal>X-ENUM</literal></term>
    <listitem>
     <para>Used to define a syntax that is an enumeration of values. The
     following attribute syntax description defines a syntax allowing four
     possible attribute values for example.</para>
     <programlisting language="ldif"
     >ldapSyntaxes: ( security-label-syntax-oid DESC 'Security Label'
 X-ENUM ( 'top-secret' 'secret' 'confidential' 'unclassified' ) )</programlisting>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>X-PATTERN</literal></term>
    <listitem>
     <para>Used to define a syntax based on a regular expression pattern, where
     valid regular expressions are those defined for <link xlink:show="new"
     xlink:href="http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html"
     ><literal>java.util.regex.Pattern</literal></link>. The following attribute
     syntax description defines a simple, lenient SIP phone URI syntax
     check.</para>
     <programlisting language="ldif"
     >ldapSyntaxes: ( simple-sip-uri-syntax-oid DESC 'Lenient SIP URI Syntax'
 X-PATTERN '^sip:[a-zA-Z0-9.]+@[a-zA-Z0-9.]+(:[0-9]+)?$' )</programlisting>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>X-SUBST</literal></term>
    <listitem>
     <para>Used as a fallback to substitute a defined syntax for one that
     OpenDJ does not implement. The following example substitutes Directory
     String syntax, which has OID 1.3.6.1.4.1.1466.115.121.1.15, for a syntax
     that OpenDJ does not implement.</para>
     <programlisting language="ldif"
     >ldapSyntaxes: ( non-implemented-syntax-oid DESC 'Not Implemented in OpenDJ'
 X-SUBST '1.3.6.1.4.1.1466.115.121.1.15' )</programlisting>
    </listitem>
   </varlistentry>
  </variablelist>

  <variablelist xml:id="attr-type-schema-definition-extensions">
   <title>Extension for Attribute Type Descriptions</title>

   <indexterm>
    <primary>Schema</primary>
    <secondary>Schema definition extensions</secondary>
   </indexterm>

   <varlistentry>
    <term><literal>X-APPROX</literal></term>
    <listitem>
     <para><literal>X-APPROX</literal> is used to specify the approximate
     matching rule to use for a given attribute type when not using the default,
     which is the <link xlink:href="http://aspell.net/metaphone/"
     xlink:show="new">double metaphone approximate match</link>.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </section>
 
 <section xml:id="schema-legacy-support">
  <title>Relaxing Schema Checking to Import Legacy Data</title>
  <indexterm>
   <primary>Schema</primary>
   <secondary>Legacy data</secondary>
  </indexterm>
  
  <para>By default, OpenDJ accepts data that follows the standards in terms of
  what is allowed and what is rejected. You might have legacy data from a
  directory service that is more lenient, allowing non-standard constructions
  such as multiple structural object classes per entry, not checking attribute
  value syntax, or even not respecting schema definitions.</para>
  
  <para>For example, when importing data with multiple structural object
  classes defined per entry, you can relax schema checking to warn rather
  than reject entries having this issue.</para>
  
  <screen>$ dsconfig
 set-global-configuration-prop
 --hostname opendj.example.com
 --port 4444
 --bindDN "cn=Directory Manager"
 --bindPassword password
 --set single-structural-objectclass-behavior:warn
 --trustAll
 --no-prompt</screen>

  <para>You can allow attribute values that do not respect the defined syntax
  with the <command>dsconfig</command> command as well.</para>
  
  <screen>$ dsconfig
 set-global-configuration-prop
 --hostname opendj.example.com
 --port 4444
 --bindDN "cn=Directory Manager"
 --bindPassword password
 --set invalid-attribute-syntax-behavior:warn
 --trustAll
 --no-prompt</screen>

  <para>You can even turn off schema checking altogether, although turning
  off schema checking only really makes sense when you are absolutely sure
  that the entries and attribute values respect the schema definitions, and
  you simply want to turn off schema checking temporarily to speed up import
  processing.</para>
  
  <screen>$ dsconfig
 set-global-configuration-prop
 --hostname opendj.example.com
 --port 4444
 --bindDN "cn=Directory Manager"
 --bindPassword password
 --set check-schema:false
 --trustAll
 --no-prompt</screen>
 </section>

 <section xml:id="standard-schema">
  <title>Standard Schema Included With OpenDJ</title>
  <indexterm>
   <primary>Schema</primary>
   <secondary>Bundled definitions</secondary>
  </indexterm>
  
  <para>The following files under <filename>config/schema/</filename>
  contain schema definitions out of the box.</para>
  
  <variablelist>
   <varlistentry>
    <term>
     <filename>00-core.ldif</filename>
    </term>
    <listitem>
     <para>This file contains a core set of attribute type and objectlass
     definitions from several standard LDAP documents, including
     draft-ietf-boreham-numsubordinates, draft-findlay-ldap-groupofentries,
     draft-furuseth-ldap-untypedobject, draft-good-ldap-changelog,
     draft-ietf-ldup-subentry, draft-wahl-ldap-adminaddr, RFC 1274, RFC 2079,
     RFC 2256, RFC 2798, RFC 3045, RFC 3296, RFC 3671, RFC 3672, RFC 4512,
     RFC 4519, RFC 4523, RFC 4524, RFC 4530, RFC 5020, and X.501.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>01-pwpolicy.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from
     draft-behera-ldap-password-policy, which defines a mechanism for storing
     password policy information in an LDAP directory server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>02-config.ldif</filename>
    </term>
    <listitem>
     <para>This file contains the attribute type and objectclass definitions
     for use with the directory server configuration.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-changelog.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from
     draft-good-ldap-changelog, which defines a mechanism for storing
     information about changes to directory server data.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-rfc2713.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 2713, which defines a
     mechanism for storing serialized Java objects in the directory
     server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-rfc2714.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 2714, which defines a
     mechanism for storing CORBA objects in the directory server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-rfc2739.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 2739, which defines a
     mechanism for storing calendar and vCard objects in the directory server.
     Note that the definition in RFC 2739 contains a number of errors, and this
     schema file has been altered from the standard definition in order to fix
     a number of those problems.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-rfc2926.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 2926, which defines a
     mechanism for mapping between Service Location Protocol (SLP)
     advertisements and LDAP.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-rfc3112.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 3112, which defines
     the authentication password schema.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-rfc3712.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 3712, which defines a
     mechanism for storing printer information in the directory server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>03-uddiv3.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 4403,
     which defines a mechanism for storing UDDIv3 information in the directory
     server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>04-rfc2307bis.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from the
     draft-howard-rfc2307bis specification, used to store naming service
     information in the directory server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>05-rfc4876.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions from RFC 4876, which defines
     a schema for storing Directory User Agent (DUA) profiles and preferences
     in the directory server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>05-samba.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions required when storing Samba
     user accounts in the directory server.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>05-solaris.ldif</filename>
    </term>
    <listitem>
     <para>This file contains schema definitions required for Solaris and
     OpenSolaris LDAP naming services.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <filename>06-compat.ldif</filename>
    </term>
    <listitem>
     <para>This file contains the attribute type and objectclass definitions
     for use with the directory server configuration.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </section>
 <section xml:id="nf-dsr-schema">
 <title>Working With DIT Structure Rules &amp; Name Forms</title>
  <para>This section contains useful information regarding name forms and
  DIT structure rules.</para>
  <note>At this time, the OpenDJ Control Panel does not support the management
  of name forms and DIT structure rules. These schema definition types can
  only be implemented and managed by way of direct schema file edits (which will
  necessitate a restart of OpenDJ), <emphasis>or</emphasis> through a use of
  <command>ldapmodify</command> against the server's <literal>cn=schema</literal>
  context.</note>
 <section xml:id="nf-schema">
  <title>Name Forms</title>
  <para>From clause 13.1.8 of <link xlink:href="https://www.itu.int/rec/T-REC-X.501" xlink:show="new">
   <citetitle>ITU-T Rec. X.501</citetitle></link> and <link xlink:href="http://tools.ietf.org/html/rfc4512#section-4.1.7.2" xlink:show="new">
   <citetitle>Section 4.1.7.2 of RFC 4512</citetitle></link></para>
   <variablelist>
    <varlistentry>
     <listitem>
      <emphasis>name form: A name form specifies a permissible RDN for entries
      of a particular structural object class. A name form identifies a named object
      class and one or more attribute types to be used for naming (i.e., for the
      RDN). Name forms are primitive pieces of specification used in the definition
      of DIT structure rules.</emphasis>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>In simplest terms, a name form is a particular schema definition which
   requires specific RDN syntaxes for use upon entries bearing a specific 
   STRUCTURAL class.</para>
   <para>To offer an example of this, consider the following UDDIv3 name form, per
   the <filename>03-uddiv3.ldif</filename> file included with OpenDJ:</para>
   <screen>
      nameForms: ( 1.3.6.1.1.10.15.1
         NAME 'uddiBusinessEntityNameForm'
         OC uddiBusinessEntity
         MUST ( uddiBusinessKey )
         X-ORIGIN 'RFC 4403' )</screen>
   <para>This name form states that any entry bearing the STRUCTURAL class
   <literal>uddiBusinessEntity</literal> MUST ONLY be designated using the
   <literal>uddiBusinessKey</literal> as the principal RDN attribute type, for
   example, "<literal>uddiBusinessKey=ABC123</literal>".</para>
   <para>Alternatively, when devising custom name forms, it is possible to enforce
   the use of specific attribute types within multi-valued RDNs. Consider the following
   hypothetical name form:</para>
   <screen>
      nameForms: ( 1.3.6.1.4.1.56521.999.98.15
         NAME 'cnOrgForm'
         OC groupOfUniqueNames
         MUST ( cn $ o ) )</screen>
   <para>This name form states that any entry bearing the STRUCTURAL object class
   <literal>groupOfUniqueNames</literal> MUST be designated using attribute types
   <literal>cn</literal> <emphasis>and</emphasis> <literal>o</literal> for a
   qualifying entry bearing a multi-valued RDN, such as
   "<literal>cn=Auditors+o=Acme Audit Co</literal>".</para>
   <para>Name forms also allow use of MAY clauses. Consider the following
   hypothetical name form, similar to the above:</para>
   <screen>
      nameForms: ( 1.3.6.1.4.1.56521.999.98.16
         NAME 'cnOrgAltForm'
         OC groupOfUniqueNames
         MUST cn
         MAY o )</screen>
   <para>This rule enforces use of the <literal>cn</literal> RDN attribute type the
   same as before, but while it no longer requires use of <literal>o</literal>, it
   will not reject it when present. As such, either of the following RDNs are acceptable:</para>
   <itemizedlist>
    <listitem><literal>cn=Corporate Auditors</literal></listitem>
    <listitem><literal>cn=Third Party Auditors+o=Acme Audit Co</literal></listitem>
   </itemizedlist>
   <para>But, regardless of the permutations, a name form does little good in practice
   -- unless it is referenced by a DIT structure rule.</para>
  </section>
  <section xml:id="dsr-schema">
   <title>DIT Structure Rules</title>
   <para>From clause 13.1.6 of <link xlink:href="https://www.itu.int/rec/T-REC-X.501" xlink:show="new">
   <citetitle>ITU-T Rec. X.501</citetitle></link> and <link xlink:href="http://tools.ietf.org/html/rfc4512#section-4.1.7.1" xlink:show="new">
   <citetitle>Section 4.1.7.1 of RFC 4512</citetitle></link></para>
   <variablelist>
    <varlistentry>
     <listitem><emphasis>DIT structure rule: A rule governing the structure of the DIT
     by specifying a permitted superior to subordinate entry relationship. A structure
     rule relates a name form, and therefore a structural object class, to superior
     structure rules. This permits entries of the structural object class identified
     by the name form to exist in the DIT as subordinates to entries governed by the
     indicated superior structure rules.</emphasis></listitem>
    </varlistentry>
   </variablelist>
   <para>In short, a DIT structure rule enforces the terms of its prescribed name form.
   To offer a simple analogy, if a name form presents a law, the DIT structure rule is
   the public official upholding that law.</para>
   <para>Consider this structure rule, per the included <filename>03-uddiv3.ldif</filename>
   file:</para>
   <screen>
     dITStructureRules: ( 1
        NAME 'uddiBusinessEntityStructureRule'
        FORM uddiBusinessEntityNameForm
        X-ORIGIN 'RFC 4403' )</screen>
   <para>This rule employs the <literal>uddiBusinessEntityNameForm</literal> definition,
   and constrains entries bearing the STRUCTURAL object class of the name form -- also
   known as the <literal>namedObjectClass</literal> -- to the RDN attribute type (in this
   case, <literal>uddiBusinessKey</literal>).</para>
   <para>When a DIT structure rule is introduced to the directory schema, it will not
   be evaluated until an entry is added to the DIT it enforces.</para>
   <para>DIT structure rules shall not influence preexisting entries, even if based
   upon now-illegal STRUCTURAL class and RDN combinations.</para>
   <para>Once structure rules have been established, when a new entry is added to, or
   renamed within the DIT in violation of a structure rule, OpenDJ will return "Object
   class violation (65)" along with additional contextual information for debugging
   purposes.</para>
   <note><para>As of version 4.8.0, OpenDJ is currently using the result code of "Object
   class violation (65)" for certain name form related errors, where it should be using
   "Naming violation (64)".</para>
   <para>This issue will be resolved in a future release of the package to avoid introducing
   breaking changes. Users are advised to update any external scripts or applications which
   may match the <emphasis>incorrect result code</emphasis>, and take steps to allow recognition
   of the <emphasis>correct result code</emphasis> in parallel for maximum compatibility.</para></note>
   <para>But when a new entry is successfully added to or renamed within the DIT, a new
   operational attribute type appears on the entry: <literal>governingStructureRule</literal>.</para>
   <para>From clause 13.1.7 of <link xlink:href="https://www.itu.int/rec/T-REC-X.501" xlink:show="new">
   <citetitle>ITU-T Rec. X.501:</citetitle></link></para>
   <variablelist>
    <varlistentry>
     <listitem>
      <emphasis>Governing structure rule (of an entry): With respect to a particular
      entry, the single DIT structure rule that applies to the entry. This rule is indicated
      by the governingStructureRule operational attribute.</emphasis>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>See also <link xlink:href="http://tools.ietf.org/html/rfc4512#section-3.4.6" xlink:show="new">
   <citetitle>Section 3.4.6 of RFC 4512</citetitle></link>.</para>
   <para>In simplest terms, the <literal>governingStructureRule</literal> contains
   the integer identifier of the DIT structure rule which governs the entry. In the
   case of the above DIT structure rule, it would appear in LDAP search results as
   follows:</para>
   <variablelist>
    <varlistentry>
     <term><literal>governingStructureRule: 1</literal></term>
    </varlistentry>
   </variablelist>
   <para>Instances of this attribute type may be used for diagnostic reasons, or
   by client applications designed to determine the appropriate RDN syntax to
   be applied for a new entry, or for an entry being renamed and/or moved, in
   advance of the request.</para>
   <para>DIT structure rules can be configured in such a way that a particular rule
   extends from, or is subordinate to, another DIT structure rule using the SUP clause.</para>
   <tip>A superior DIT structure rule is often referred to as a superior structure
   rule, per clause 13.1.9 of <link xlink:href="https://www.itu.int/rec/T-REC-X.501" xlink:show="new">
   <citetitle>ITU-T Rec. X.501</citetitle></link>.</tip>
   <para>The purpose of the SUP clause is to allow an entry with a particular RDN
   syntax to reside beneath one of multiple possible choices. For example:</para>
   <variablelist>
    <varlistentry>
     <screen>SUP ( 20 21 )</screen>
    </varlistentry>
   </variablelist>
   <para>In this example, the integer identifiers 20 and 21 indicate that the bearer
   of this clause will allow entries to reside as subordinates to <emphasis>either</emphasis>
   of the entries governed by those rules.</para>
   <para>Also note that rules can be <emphasis>recursive</emphasis> or "self-referencing".
   This manifests as an instance where a DIT structure rule possesses a SUP clause member
   that matches its own integer identifier. This is a particularly useful feature because
   it allows nesting of compliant entries -- for example, those bearing the <literal>organizationalUnit</literal>
   STRUCTURAL class -- to exist within superior entries of like-design.</para>
   <para>For an example of recursive rules in action, see the <literal>ouStructure</literal>
   rule (21) in the next section.</para>
   </section>
   <section xml:id="dsr-dit-design-schema">
   <title>DIT Design Under Governance - A Practical Overview</title>
   <para>This section will cover the highlights of creating initial DIT content while
   under the control of easily-understood DIT structure rules enforcing the use of
   common attribute types within entry RDNs.</para>
   <para>The following basic assumptions apply:</para>
   <itemizedlist>
    <listitem><para>A new <literal>userRoot</literal> backend exists <emphasis>and</emphasis>
    is identified by the <literal>base-dn</literal> of <literal>dc=example,dc=com</literal>,
    containing no entries whatsoever, and ...</para></listitem>
    <listitem><para>The eight (8) definitions described have already been saved
    to <literal>/opt/opendj/config/schema/99-user.ldif</literal> or a similar
    file, or otherwise added via <command>ldapmodify</command></para></listitem>
   </itemizedlist>
   <para>To begin, let's take a look at the following <literal>nameForms</literal>
   definitions:</para>
   <screen>
      #
      nameForms: ( 1.3.6.1.4.1.56521.999.2.7.1
         NAME 'rootSuffixForm'
         OC domain
         MUST dc )
      #
      nameForms: ( 1.3.6.1.4.1.56521.999.2.7.2
         NAME 'ouForm'
         OC organizationalUnit
         MUST ou )
      #
      nameForms: ( 1.3.6.1.4.1.56521.999.2.7.3
         NAME 'accountForm'
         OC inetOrgPerson
         MUST uid )
      #
      nameForms: ( 1.3.6.1.4.1.56521.999.2.7.4
         NAME 'groupForm'
         OC groupOfNames
         MUST cn )</screen>
   <para>These name forms declare the following mandates:</para>
   <itemizedlist>
    <listitem>Entries bearing the <literal>domain</literal> STRUCTURAL class,
    MUST utilize <literal>dc</literal> for their respective RDNs</listitem>
    <listitem>Entries bearing the <literal>organizationalUnit</literal> STRUCTURAL
    class, MUST utilize <literal>ou</literal> for their respective RDNs</listitem>
    <listitem>Entries bearing the <literal>inetOrgPerson</literal> STRUCTURAL class,
    MUST utilize <literal>uid</literal> for their respective RDNs</listitem>
    <listitem>Entries bearing the <literal>groupOfNames</literal> STRUCTURAL class,
    MUST utilize <literal>cn</literal> for their respective RDNs</listitem>
   </itemizedlist>
   <para>Next, we'll take a look at the new <literal>dITStructureRules</literal> instances,
   which will bring the above name forms to life:</para>
   <screen>
      #
      dITStructureRules: ( 20
                NAME 'rootSuffixStructure'
                FORM rootSuffixForm )
      #
      dITStructureRules: ( 21
                NAME 'ouStructure'
                FORM ouForm
                SUP ( 20 21 ) )
      #
      dITStructureRules: ( 22
                NAME 'accountStructure'
                FORM accountForm
                SUP 21 )
      #
      dITStructureRules: ( 23
                NAME 'groupStructure'
                FORM groupForm
                SUP 21 )</screen>
   <para>From these rules, one can begin to perceive an abstract DIT structure,
   defined by the incrementing -- and hierarchically-significant -- integer
   identifiers, each of which reflect the following respective conditions:</para>
   <itemizedlist>
    <listitem><para>Given the absence of other entries, the introduction of an entry
    bearing the <literal>domain</literal> STRUCTURAL class and <literal>dc</literal> RDN
    attribute signifies the start of the administrative area, or the start of the "chain
    of enforced rules"</para>
    <para>When added, this entry SHOULD bear a <literal>governingStructureRule</literal>
    integer identifier of 20</para></listitem>
    <listitem><para>Given the introduction of an entry, positioned directly subordinate to
    the root suffix and bearing the <literal>organizationalUnit</literal> STRUCTURAL
    class and <literal>ou</literal> RDN attribute, the entry is accepted</para>
    <para>When added, this entry SHOULD bear a <literal>governingStructureRule</literal>
    integer identifier of 21, the subordinate structure rule of its superior structure
    rule, 20</para></listitem>
    <listitem><para>Given the introduction of any additional <literal>organizationalUnit</literal>
    entries, whether descending directly from the root suffix, OR if subordinate to other
    <literal>organizationalUnit</literal> entries in "nested" fashion, the entry is accepted
    by rite of structure rule recursion</para>
    <para>When added, this entry SHOULD also bear a <literal>governingStructureRule</literal>
    integer identifier of 21, as with the previous case</para></listitem>
    <listitem><para>Given the introduction of an entry, positioned directly subordinate to any
    <literal>organizationalUnit</literal> entry presently governed by DIT structure rule 21
    and bearing the <literal>inetOrgPerson</literal> STRUCTURAL class and <literal>uid</literal>
    RDN attribute, the entry is accepted</para>
    <para>When added, this entry SHOULD bear a <literal>governingStructureRule</literal> integer
    identifier of 22</para></listitem>
    <listitem><para>Given the introduction of an entry, positioned directly subordinate to any
    <literal>organizationalUnit</literal> entry presently governed by DIT structure rule 21
    and bearing the <literal>groupOfNames</literal> STRUCTURAL class and <literal>cn</literal>
    RDN attribute, the entry is accepted</para>
    <para>When added, this entry SHOULD bear a <literal>governingStructureRule</literal> integer identifier
    of 23</para></listitem>
   </itemizedlist>
   <para>Next, we'll be creating the initial portions of the governed DIT using <command>ldapmodify</command>,
   and periodically checking the results with <command>ldapsearch</command> along the way.</para>
   <note>In cases where changes are made in this section, the root DN user (<literal>cn=Directory Manager</literal>)
   is purposely used. This is simply to demonstrate that no user, regardless of privilege, can "bypass" or
   otherwise violate DIT structure rules in force.</note>
   <screen>
    $ ldapmodify -w password \ 
      -D "cn=Directory Manager" \
      -h opendj.example.com

    dn: dc=example,dc=com
    changetype: add
    objectClass: domain

    Processing ADD request for dc=example,dc=com
    ADD operation successful for DN dc=example,dc=com
    
    dn: ou=Accounts,dc=example,dc=com
    changetype: add
    objectClass: organizationalUnit
    
    Processing ADD request for ou=Accounts,dc=example,dc=com
    ADD operation successful for DN ou=Accounts,dc=example,dc=com
    
    dn: ou=Consultants,ou=Accounts,dc=example,dc=com
    changetype: add
    objectClass: organizationalUnit

    Processing ADD request for ou=Consultants,dc=example,dc=com
    ADD operation successful for DN ou=Consultants,dc=example,dc=com</screen>
   <para>So far, so good. What we've just done is create the initial structure of
   our DIT, and in doing so we've confirmed the DIT structure rules do not seem
   to be interfering.</para>
   <para>But, let's stop for now and check our work. We want to see the DIT structure
   rules that are <emphasis>actively</emphasis> governing our entries. To do this, we
   need only perform a simple anonymous LDAP search:</para>
   <screen>
    $ ldapsearch -h opendj.example.com \
      -b dc=example,dc=com \
      "(objectClass=*)" \
      governingStructureRule

    dn: dc=example,dc=com
    governingStructureRule: 20
    
    dn: ou=Accounts,dc=example,dc=com
    governingStructureRule: 21
    
    dn: ou=Consultants,ou=Accounts,dc=example,dc=com
    governingStructureRule: 21</screen>
   <para>This proves the following:</para>
   <itemizedlist>
    <listitem>Rule 20, the <literal>rootSuffixStructure</literal> definition,
    represents the start of the structure chain</listitem>
    <listitem>Rule 21, the <literal>ouStructure</literal> definition, represents
    the permitted subordinate naming context below entries governed by the
    <literal>rootSuffixStructure</literal> rule</listitem>
    <listitem>Rule 21, as it supports recursion by nature, allows <literal>organizationalUnit</literal>
    entries to reside <emphasis>within </emphasis> <literal>organizationalUnit</literal> entries, thus
    allowing categorical organizational structures to exist</listitem>
   </itemizedlist>
   <para>Let's see what happens when we attempt to add an entry bearing an unauthorized RDN syntax.</para>
   <screen>
    $ ldapmodify -w password \
      -D "cn=Directory Manager"\
      -h opendj.example.com

    dn: mail=user@example.com,ou=Consultants,ou=Accounts,dc=example,dc=com
    changetype: add
    objectClass: inetOrgPerson
    cn: User Person
    sn: Person

    Processing ADD request for
    mail=user@example.com,ou=Consultants,ou=Accounts,dc=example,dc=com
    The LDAP modify request failed: 65 (Object Class Violation)
    Additional Information:  Entry
    mail=user@example.com,ou=Consultants,ou=Accounts,dc=example,dc=com violates
    the Directory Server schema configuration because its RDN does not contain
    attribute uid that is required by name form accountForm</screen>
   <para>Good, the DIT structure rule in question seems to work in preventing bogus RDNs.
   Now let's continue with entries that are expected to work.</para>
   <screen>
    $ ldapmodify -w password \
      -D "cn=Directory Manager" \
      -h opendj.example.com
 
    dn: uid=userPerson,ou=Consultants,ou=Accounts,dc=example,dc=com
    changetype: add
    objectClass: inetOrgPerson
    sn: Person
    cn: User Person
   
    Processing ADD request for uid=userPerson,ou=Consultants,ou=Accounts,dc=example,dc=com
    ADD operation successful for DN uid=userPerson,ou=Consultants,ou=Accounts,dc=example,dc=com
    
    dn: ou=Groups,dc=example,dc=com
    changetype: add
    objectClass: organizationalUnit
    
    Processing ADD request for ou=Groups,dc=example,dc=com
    ADD operation successful for DN ou=Groups,dc=example,dc=com
    
    dn: ou=Corporate,ou=Groups,dc=example,dc=com
    changetype: add
    objectClass: organizationalUnit
    
    Processing ADD request for ou=Corporate,ou=Groups,dc=example,dc=com
    ADD operation successful for DN ou=Corporate,ou=Groups,dc=example,dc=com
    
    dn: ou=Infrastructure,ou=Groups,dc=example,dc=com
    changetype: add
    objectClass: organizationalUnit
    
    Processing ADD request for ou=Infrastructure,ou=Groups,dc=example,dc=com
    ADD operation successful for DN ou=Infrastructure,ou=Groups,dc=example,dc=com
    
    dn: cn=Abuse Mail,ou=Infrastructure,ou=Groups,dc=example,dc=com
    changetype: add
    objectClass: groupOfNames
    
    Processing ADD request for cn=Abuse Mail,ou=Infrastructure,ou=Groups,dc=example,dc=com
    ADD operation successful for DN cn=Abuse Mail,ou=Infrastructure,ou=Groups,dc=example,dc=com</screen>
   <para>Again, let's check our work (omitting the contents of the previous LDAP search):</para>
   <screen>
    $ ldapsearch -h opendj.example.com \
      -b dc=example,dc=com \
      "(objectClass=*)" \
      governingStructureRule
 
    dn: uid=userPerson,ou=Consultants,ou=Accounts,dc=example,dc=com
    governingStructureRule: 22
    
    dn: ou=Groups,dc=example,dc=com
    governingStructureRule: 21
    
    dn: ou=Corporate,ou=Groups,dc=example,dc=com
    governingStructureRule: 21
    
    dn: ou=Infrastructure,ou=Groups,dc=example,dc=com
    governingStructureRule: 21
    
    dn: cn=Abuse Mail,ou=Infrastructure,ou=Groups,dc=example,dc=com
    governingStructureRule: 23</screen>
   <para>So, what did we learn?</para>
   <itemizedlist>
    <listitem><literal>ouStructure</literal> rule 21 continues to allow recursive
    <literal>organizationalUnit</literal> entries, so long as they ultimately extend
    from the <literal>rootSuffixStructure</literal> superior structure (ancestor)
    rule 20, <emphasis>or</emphasis> another such entry governed by rule 21</listitem>
    <listitem><literal>accountStructure</literal> rule 22 is correctly governing
    entries bearing the <literal>inetOrgPerson</literal> STRUCTURAL class found
    within an <literal>organizationalUnit</literal> entry (superior structure rule
    21)</listitem>
    <listitem><literal>groupStructure</literal> rule 23 is correctly governing entries
    bearing the <literal>groupOfNames</literal> STRUCTURAL class found within an
    <literal>organizationalUnit</literal> entry (superior structure rule 21)</listitem>
   </itemizedlist>
   <para>DIT structure rules are extremely powerful. When properly planned and implemented,
   they can greatly aid in the formation of clean and orderly directory structures without
   the need for additional ACIs.</para>
   </section>
   <section id="dsr-impl-preexist-dit-schema">
    <title>Considerations Relating To The Implementation Of DIT Structure Rules In
    An Established DIT</title>
    <para>Because DIT structure rules do not influence preexisting entries, even those
    in violation of those rules, this presents a potential pain-point regarding the
    restoration of content that (in some way) predates the incorporation of those DIT
    structure rules. This situation may apply following a disaster-triggered reload of
    data, or when using this data to "seed" a new DSA being built in the topology.</para>
    <para>If DIT structure rules are already applied to the DSA in question, but data has
    NOT yet been loaded, the DIT structure rules in question will consider ANY data to be
    "new" regardless of its true chronological age.</para>
    <para>If violations are perceived, this will result in errors during the incorporation
    of that data. This can be confusing to administrators if that same data exists as
    expected on other DSAs -- even those with effectively identical configurations.</para>
    <para>When introducing DIT structure rules to an established (preexisting) DIT, it is
    strongly recommended that separate load-tests be conducted on a disposable system or
    virtual image that is under the governance of all planned DIT structure rules. This
    will allow accurate simulation of new in-topology server builds, or rebuilds of
    preexisting servers that have suffered a malfunction of some kind, or have been
    rebuilt due to upgrade or other reasons.</para>
   </section>
   <section id="dsr-subentries-schema">
    <title>Considerations For Collective Attribute Subentries</title>
    <para>DIT structure rules apply not only to standard entries as demonstrated in the
    previous section, but also to subentries -- entries that bear the <literal>subentry</literal>
    STRUCTURAL class defined in <link xlink:href="http://tools.ietf.org/html/rfc3672#section-2.4" xlink:show="new">
    <citetitle>Section 2.4 of RFC 3672</citetitle></link>.</para>
    <para>In cases where a directory server employs DIT structure rules in addition
    to collective attributes, it is necessary to implement a new <literal>dITStructureRules</literal>
    definition: one that enforces a suitable RDN attribute type (such as <literal>cn</literal>)
    for subentries, while taking into account the superior structure rule(s) involved.</para>
    <para>To begin, as was done in the previous section, a nameForms definition is required first.</para>
    <screen>
      nameForms: ( 1.3.6.1.4.1.56521.999.2.7.5
         NAME 'subentryForm'
         OC subentry
         MUST cn )</screen>
    <para>Here, we are stating that any entry bearing the <literal>subentry</literal>
    STRUCTURAL class MUST ONLY utilize the <literal>cn</literal> attribute type for
    its RDN, as it represents the most common naming strategy for subentries.</para>
    <para>Next, we need to create the DIT structure rule, but first we need to identify
    the appropriate superior integer identifiers for the SUP clause.</para>
    <para>Determining these identifiers is a simple matter. First off, subentries are never
    created below entries that are not parents themselves (or expected to be parents). In
    the spirit of the previous section, this allows us to strike two (2) candidates from
    the list: <literal>inetOrgPerson</literal> entries (accounts), and <literal>groupOfNames</literal>
    entries (groups).</para>
    <para>This leaves <literal>domain</literal> (20) and <literal>organizationalUnit</literal>
   (21) entries. Thus:</para>
   <screen>
      dITStructureRules: ( 24
         NAME 'subentryStructure'
         FORM subentryForm
         SUP ( 20 21 ) )</screen>
   <para>Because subentries themselves do not allow for subordinate entries, we need
   not worry about rule recursion in this instance.</para>
   <para>When implemented (and with respect to the parameters of the previous subsection),
   the definitions defined in this subsection will correctly allow for the addition of
   entries bearing the <literal>subentry</literal> STRUCTURAL class, thus allowing use
   of dependent constructs, such as collective attributes, to be used unfettered.</para>
  </section>
  <section id="aci-vs-dsr-schema">
   <title>ACIs Vs. DIT Structure Rules</title>
   <para>Some LDAP implementations on the market today offer no support for DIT structure
   rules. A common workaround for this is the use of ACIs to enforce specific naming
   conventions for entries. While OpenDJ supports this technique just the same, there
   are potential caveats.</para>
   <para>Use of ACIs to enforce such rules can be bypassed by users with sufficient access
   privileges. DIT structure rules, on the other hand, are defined in the schema, which
   conceptually exists at a lower and more fundamental level than ACIs. As such, no user can
   bypass a DIT structure rule using conventional means -- not even the root DN.</para>
   <para>There is also the classic argument that use of ACIs to effect "behavioral changes"
   in this manner is contrary to the very intent of ACIs. Because DIT structure rules are
   essentially immutable and do not discriminate the origin of any request, they resemble
   configuration directives in practice more so than an expression of privilege.</para>
   <para>The argument against ACIs in this context gains additional momentum when one
   considers the innate risk of altering ACIs for any reason, as even the slightest
   misstep can deny critical functionality or, worse, expose data.</para>
  </section>
 </section>
</chapter>
